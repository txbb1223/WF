Step 3 and 4:

- The main.py demonstrates the use of C++ myMatrix in python (create an instance and did elementwise addition).

- Steps to create the python wrapper:
	a. Install SWIG.
	b. Create an interface file myMatrix.h which makes reference to the C++ source file and define the python module as myMatrix.
	c. Run the following commands:
		-- swig -c++ -python myMatrix.i
		-- gcc -fPIC -c myMatrix.cpp
		-- gcc -fPIC -c myMatrix_wrap.cxx -I/Library/Frameworks/Python.framework/Versions/3.9/include/python3.9/
		-- gcc -shared myMatrix.o myMatrix_wrap.o -o _myMatrix.so

- Step c generates the myMatrix_wrap.cxx and myMatrix.py files and then compile and link. Note that myMatrix.py is the proxy class in python generated by SWIG that calls the wrapper code around the C++ class. It provides the way to utilize C++ code in python. For example, myMatrix.py has the python "class myMatrix(object)" which inclues all the python mappings to the members and functions of the C++ myMatrix class. When the C++ source code gets updated, running swig -c++ -python myMatrix.i will have this update reflected in the wrapper code myMatrix_wrap.cxx and then in myMatrix.py.

- (Not entirely sure) Setup will be called after importing the proxy class module to the drive code and before actual calls to the proxy class (since it's supposed to the preparation work which we do not want to to repeat for very function call. TearDown will be called when the program terminates.

- Memory managment: in my main.py, instances of the Python proxy class and the underlying C++ class are both created. And when the python instance is deleted, it is unclear whether the original C++ object is also deleted or is still alive. SWIG provides ways to control ownership of an object (whether owned and deallocated by Python or C++), which can be done by setting ownership in the interface code (.i file). An example is adding %newobject - if C++ returns a value that is a newly allocated object, Python is not aware of it and simply creates a wrapper around it. At the end it will delete the wrapper instance but without deallocating the actuall C++ object. In this case %newobject can be added to the interface file such that Python takes ownership and will automatically deallocate when it reaches the end of life. IMO using %newobject seems similar to interaction between C++ shared and weak pointers - shared ptrs take ownership and increment refCount (analogous to Python wrapper), while weak ptrs simply increment refCount but does not take onwership (analogous to C++ underlying class).





